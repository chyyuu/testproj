1.4                  ModuleExecutionDetector插件
------------------------------------------------

### 1.4.1 初识ModuleExecutionDetector插件

ModuleExecutionDetector插件的作用是当进入或离开一个我们感兴趣的模块时告知其他插件。它依赖于一个OS
monitor插件来定位模块在内存中的地址。

### 1.4.2 ModuleExecutionDetector插件的使用

配置文件：
 
    pluginsConfig.ModuleExecutionDetector = {
	--将所有模块的加载和卸载事件通知给其他插件,但是不追踪这些模块的执行
	trackAllModules=false,
	--把所有的模块都作为我们感兴趣的模块,如果此域为 true,则忽略下面配置的各
	模块
	configureAllModules=false,
	module_id1 = {
	--要监视的模块名称
	moduleName=”notepad.exe",
	--标志此模块是位于内核空间还是用户空间
	kernelMode= false,
	},
	module_id2 ={
	...
	},
	}

### 1.4.3 ModuleExecutionDetector插件的分析

####1.4.3.1 ModuleExecutionDetector 插件的初始化

 

ModuleExecutionDetector插件首先初始化，完成以下几项工作：

1、连接OSMonitor插件发送的onModuleLoad、onModuleUnload和onProcessUnload信号；

2、连接CorePlugin插件发送的onTranslateBlockStart、onTranslateBlockEnd、onException和onCustomInstruction信号；

3、读取配置文件中的信息。 
初始化在ModuleExecutionDetector.cpp中实现，代码如下：

	void ModuleExecutionDetector::initialize()
	{
	m_Monitor = (OSMonitor*)s2e()->getPlugin("Interceptor");
	assert(m_Monitor);
	//对 OSMonitor 插件发送的相关信号的连接
	m_Monitor->onModuleLoad.connect(
	sigc::mem_fun(*this, &ModuleExecutionDetector::moduleLoadListener));
	m_Monitor->onModuleUnload.connect(
	sigc::mem_fun(*this, &ModuleExecutionDetector::moduleUnloadListener));
	m_Monitor->onProcessUnload.connect(
	sigc::mem_fun(*this, &ModuleExecutionDetector::processUnloadListener));
	//对 CorePlugin 插件发送的相关信号的连接
	s2e()->getCorePlugin()->onTranslateBlockStart.connect(
	sigc::mem_fun(*this, &ModuleExecutionDetector::onTranslateBlockStart));
	s2e()->getCorePlugin()->onTranslateBlockEnd.connect(
	sigc::mem_fun(*this, &ModuleExecutionDetector::onTranslateBlockEnd));
	s2e()->getCorePlugin()->onException.connect(
	sigc::mem_fun(*this, &ModuleExecutionDetector::exceptionListener));
	s2e()->getCorePlugin()->onCustomInstruction.connect(
	sigc::mem_fun(*this, &ModuleExecutionDetector::onCustomInstruction));
	//读取配置文件中的信息,主要是配置的需要追踪的模块的id和名称存入集合
	//m_ConfiguredModulesId 和 m_ConfiguredModulesName 中
	initializeConfiguration();
	}

####1.4.3.2 对onModuleLoad信号的处理 

ModuleExecutionDetector插件连接OSMonitor发送的onModuleLoad信号，这里的OSMonitor插件以WindowsMonitor为例。前面讲到WindowsMonitor插件在翻译每条指令时，根据当前状态的pc判断如果正在加载模块，就发送onModuleLoad信号。这里ModuleExecutionDetector插件连接此信号后，调用moduleLoadListener函数进行相应处理。

此函数主要完成以下几项工作：

1、如果配置文件中定义所有模块都是感兴趣的模块（configureAllModules=true），则将当前模块加入到事先定义的集合（m\_Descriptors）中去，并且发送ModuleExecutionDetector插件的onModuleLoad信号。

	if (m_ConfigureAllModules) {
	if (plgState->exists(&module, true)) { //该模块已经加载过
	s2e()->getDebugStream() << " [ALREADY REGISTERED]" << std::endl;
	}else {
	//该模块未加载过
	s2e()->getDebugStream() << " [REGISTERING]" << std::endl;
	//加入到 m_Descriptors 集合中
	plgState->loadDescriptor(module, true);
	onModuleLoad.emit(state, module);
	}
	return;
	}

2、对配置文件中定义的模块，判断当前模块是否是我们感兴趣的模块，则将当前模块加入到事先定义的集合（m\_Descriptors）中去，并且发送ModuleExecutionDetector插件的onModuleLoad信号。

	ConfiguredModulesByName::iterator it = m_ConfiguredModulesName.find(cfg);
	if (it != m_ConfiguredModulesName.end()) {
	if (plgState->exists(&module, true)) {
	s2e()->getDebugStream() << " [ALREADY REGISTERED ID=" << (*it).id
	<< "]" << std::endl;
	}else {
	s2e()->getDebugStream() << " [REGISTERING ID=" << (*it).id << "]" <<
	std::endl;
	plgState->loadDescriptor(module, true);
	onModuleLoad.emit(state, module);
	}
	return;
	}

3、如果配置文件中定义了trackAllModules=true，则加入事先定义的集合m\_NotTrackedDescriptors中去，并且发送ModuleExecutionDetector插件的onModuleLoad信号。

	if (m_TrackAllModules) {
	if (!plgState->exists(&module, false)) {
	s2e()->getDebugStream() << " [REGISTERING NOT TRACKED]" <<
	std::endl;
	plgState->loadDescriptor(module, false);
	onModuleLoad.emit(state, module);
	}
	return;
	}
	
[模块的描述]

每一个模块都由ModuleDescriptor结构来描述：

	struct ModuleDescriptor
	{
	uint64_t Pid;
	//The name of the module (eg. MYAPP.EXE or DRIVER.SYS)
	std::string Name;
	//Where the the prefered load address of the module.
	//This is defined by the linker and put into the header of the image.
	uint64_t NativeBase;
	//Where the image of the module was actually loaded by the OS.
	uint64_t LoadBase;
	//The size of the image of the module
	uint64_t Size;
	//The entry point of the module
	uint64_t EntryPoint;
	//A list of sections
	ModuleSections Sections;
	ModuleDescriptor() {
	Pid = 0;
	NativeBase = 0;
	LoadBase = 0;
	Size = 0;
	EntryPoint = 0;
	}
	bool Contains(uint64_t RunTimeAddress) const {
	uint64_t RVA = RunTimeAddress - LoadBase;
	return RVA < Size;
	}
	uint64_t ToRelative(uint64_t RunTimeAddress) const {
	uint64_t RVA = RunTimeAddress - LoadBase;
	return RVA;
	}
	uint64_t ToNativeBase(uint64_t RunTimeAddress) const {
	return RunTimeAddress - LoadBase + NativeBase;
	}
	uint64_t ToRuntime(uint64_t NativeAddress) const {
	return NativeAddress - NativeBase + LoadBase;
	}
	bool EqualInsensitive(const char *Name) const{
	return strcasecmp(this->Name.c_str(), Name) == 0;
	}
	struct ModuleByLoadBase {
	bool operator()(const struct ModuleDescriptor& s1,
	const struct ModuleDescriptor& s2) const {
	if (s1.Pid == s2.Pid) {
	return s1.LoadBase + s1.Size <= s2.LoadBase;
	}
	return s1.Pid < s2.Pid;
	}
	};
	bool operator()(const struct ModuleDescriptor* s1,
	const struct ModuleDescriptor* s2) const {
	if (s1->Pid == s2->Pid) {
	return s1->LoadBase + s1->Size <= s2->LoadBase;
	}
	return s1->Pid < s2->Pid;
	}
	struct ModuleByName {
	bool operator()(const struct ModuleDescriptor& s1,
	const struct ModuleDescriptor& s2) const {
	return s1.Name < s2.Name;
	}
	};
	bool operator()(const struct ModuleDescriptor* s1,
	const struct ModuleDescriptor* s2) const {
	return s1->Name < s2->Name;
	}
	void Print(std::ostream &os) const {
	};
	os << "Name=" << Name << std::hex <<
	" NativeBase=0x" << NativeBase << " LoadBase=0x" << LoadBase <<
	" Size=0x" << Size <<
	" EntryPoint=0x" << EntryPoint <<
	std::dec << std::endl;
	typedef std::set<struct ModuleDescriptor, ModuleByLoadBase> MDSet;
	};
	}

其中包含了很多信息，包括模块的名称、大小、加载地址等，并且提供了一些计算地址的函数。

除了onModuleload信号外还有onModuleUnload和onProcessUnload信号，对这两个信号的处理是通过调用函数ModuleExecutionDetector::moduleUnloadListener和ModuleExecutionDetector::processUnloadListener来实现的，这两个函数的功能很简单，只是输出相应的提示信息后分别调用各自相应的处理函数，代码如下所示：

    void ModuleExecutionDetector::moduleUnloadListener(
	    S2EExecutionState* state, const ModuleDescriptor &module)
	{
	    DECLARE_PLUGINSTATE(ModuleTransitionState, state);
	//输出提示信息
	    s2e()->getDebugStream() << "Module " << module.Name << " is unloaded" << '\n';
	//调用处理函数
	    plgState->unloadDescriptor(module);
	}

	void ModuleExecutionDetector::processUnloadListener(
	    S2EExecutionState* state, uint64_t pid)
	{
	    DECLARE_PLUGINSTATE(ModuleTransitionState, state);
	//输出提示信息
	    s2e()->getDebugStream() << "Process " << hexval(pid) << " is unloaded\n";
	//调用处理函数
	    plgState->unloadDescriptorsWithPid(pid);
	} 

####1.4.3.3 对onTranslationBlockStart信号的处理

ModuleExecutionDetector插件连接OSMonitor发送的onTranslationBlockStart信号，这里的OSMonitor插件以WindowsMonitor为例。前面讲到WindowsMonitor插件在翻译每个基本块时都会发送这个信号。这里ModuleExecutionDetector插件连接此信号后，调用onTranslateBlockStart函数进行相应处理。函数主要完成的工作是判断当前模块是否需要追踪，如果是我们感兴趣的模块，则发送ModuleExecutionDetector的onModuleTranslateBlockStart信号。
代码如下：

	void ModuleExecutionDetector::onTranslateBlockStart(
	ExecutionSignal *signal,
	S2EExecutionState *state,
	TranslationBlock *tb,
	uint64_t pc)
	{
	DECLARE_PLUGINSTATE(ModuleTransitionState, state);
	uint64_t pid = m_Monitor->getPid(state, pc);
	//根据 pid 和 pc 判断当前运行的是否是我们关注的模块(在集合 m_Descriptors 中
	查找)[a]
	const ModuleDescriptor *currentModule =
	plgState->getDescriptor(pid, pc);
	if (currentModule) {
	 //是我们感兴趣的模块
	//S2E::printf(s2e()->getDebugStream(), "Translating block %#"PRIx64"
	belonging to %s\n",pc, currentModule->Name.c_str());
	//连接 onExecution 信号,并调用 onExecution 函数处理,主要是针对模块
	转换的,这里不仔细看
	signal->connect(sigc::mem_fun(*this,
	&ModuleExecutionDetector::onExecution));
	}
	}
	//发送 onModuleTranslateBlockStart 信号
	onModuleTranslateBlockStart.emit(signal, state, *currentModule, tb, pc);

[a]
getDescriptor()函数负责查找当前模块是否是我们关注的模块。原理是将pc和集合中每个模块的加载地址进行比较，判断pc是否在其中。

####1.4.3.4 对 onTranslationBlockEnd 信号的处理

ModuleExecutionDetector 插件连接 corePlugin发送的onTranslationBlockEnd 信号。这里 ModuleExecutionDetector 插件连接此信号后,调用onTranslateBlockEnd 函数进行相应处理。该函数首先获得当前模块（currentModule），然后判断是否是静态目标，如果是则得到目标模块（targetModule）并判断目的模块是否和当前模块不同，如果是则直接连接到传入的执行信号（ExecutionSignal）signal，对该信号的处理是通过调用oduleExecutionDetector::onExecution函数来实现的，否则不做任何处理；如果目标是非静态的，即动态的，则直接链接到signal。最后函数会发送onModuleTranslateBlockEnd信号。代码如下所示：

	void ModuleExecutionDetector::onTranslateBlockEnd(
		ExecutionSignal *signal,
		S2EExecutionState* state,
		TranslationBlock *tb,
		uint64_t endPc,
		bool staticTarget,
		uint64_t targetPc)
	{
	    DECLARE_PLUGINSTATE(ModuleTransitionState, state);
	    //获取当前模块
	    const ModuleDescriptor *currentModule = getCurrentDescriptor(state);
	    if (!currentModule) {
		// Outside of any module, do not need
		// to instrument tb exits.
		return;
	    }
	    if (staticTarget) {//如果目标是静态的
		//获取目标模块
		const ModuleDescriptor *targetModule =
		    plgState->getDescriptor(m_Monitor->getPid(state, targetPc), targetPc);
		if (targetModule != currentModule) {//判断目标模块是否和当前模块不同
		    //Only instrument in case there is a module change
		    //TRACE("Static transition from %#"PRIx64" to %#"PRIx64"\n",
		    //    endPc, targetPc);
		    //连接到signal
		    signal->connect(sigc::mem_fun(*this,
		        &ModuleExecutionDetector::onExecution));
		}
	    }else {//目标是动态的
		//TRACE("Dynamic transition from %#"PRIx64" to %#"PRIx64"\n",
		//        endPc, targetPc);
		//In case of dynamic targets, conservatively
		//instrument code.
		signal->connect(sigc::mem_fun(*this,
		        &ModuleExecutionDetector::onExecution));
	    }
	    if (currentModule) {//发送onMuduleTranslateBlockEnd信号
	       onModuleTranslateBlockEnd.emit(signal, state, *currentModule, tb, endPc,
		staticTarget, targetPc);
	    }
	}

####1.4.3.5 对onException信号的处理

ModuleExecutionDetector 插件连接 corePlugin发送的 onException信号。这里 ModuleExecutionDetector 插件连接此信号后,调用exceptionListener 函数进行相应处理。
该函数的功能很简单，如果plgState的指向先前的模块的指针（m_PreviousModule）不为空的话则发送onModuleTransition信号并使指针为空，代码如下：

	void ModuleExecutionDetector::exceptionListener(
		               S2EExecutionState* state,
		               unsigned intNb,
		               uint64_t pc
		               )
	{
	    //std::cout << "Exception index " << intNb << '\n';
	    //onExecution(state, pc);
	    DECLARE_PLUGINSTATE(ModuleTransitionState, state);
	    //gTRACE("pid=%#"PRIx64" pc=%#"PRIx64"\n", pid, pc);
	    if (plgState->m_PreviousModule != NULL) {
		onModuleTransition.emit(state, plgState->m_PreviousModule, NULL);
		plgState->m_PreviousModule = NULL;
	    }
	}

####1.4.3.6 对onCustomInstruction信号的处理

ModuleExecutionDetector 插件连接 corePlugin发送的onCustomInstruction信号。这里 ModuleExecutionDetector 插件连接此信号后,调用onCustomInstruction 函数进行相应处理。该函数首先会检查传入的表达式operand中是否含有MODULE_EXECUTION_DETECTOR_OPCODE，如果不包含则直接结束，如果包含则获取表达式operand中的一个8位的函数代码（8-bit function code ），然后根据这个8位的代码的不同情况采取不同的处理，代码如下：

	void ModuleExecutionDetector::onCustomInstruction(
		S2EExecutionState *state,
		uint64_t operand
		)
	{
	    //检测operand中的制定的opcode
	    if (!OPCODE_CHECK(operand, MODULE_EXECUTION_DETECTOR_OPCODE)) {
		return;
	    }
	    uint64_t subfunction = OPCODE_GETSUBFUNCTION(operand);
	    switch(subfunction) {
		case 0: {
		    if (opAddModuleConfigEntry(state)) {
		        tb_flush(env);
		        state->setPc(state->getPc() + OPCODE_SIZE);
		        throw CpuExitException();
		    }
		    break;
		}
	    }
	}

 

1.5 FunctionMonitor插件
----------------------------------------

### 1.5.1 初识FunctionMonitor插件

FunctionMonitor
插件捕获所有的call/return机器指令，并且可以定义自己的回调函数来处理。

### 1.5.2 FunctionMonitor 插件的使用

​1. 自己编写一个插件P；

 

​2. 在插件P的initialize()初始化函数中得到FunctionMonitor插件的实例；

	FunctionMonitor *m_monitor
	=static_cast<FunctionMonitor*>(s2e()->getPlugin("FunctionMonitor"));

​3.
连接一个将S2EExecutionState类型的变量作为参数的信号，如所有的CorePlugin发出的信号。

	s2e()->getCorePlugin()->onTranslateBlockStart.connect(sigc::mem_fun(*this,&Example::slotTranslateBlockStart)); 

​4. 得到想要监控的函数的地址fa；

 

​5. 注册call信号；

	callSignal = m_monitor->getCallSignal(state, functionAddress, -1);
	callSignal->connect(sigc::mem_fun(*this, &P::myFunctionCallMonitor));
	//P::myFunctionCallMonitor 是自己定义的回调函数

​6. 如果需要的话注册ret信号。

 

### 1.5.3 FunctionMonitor插件的分析

####1.5.3.1 前置知识

 

1、函数调用的描述：使用数据结构CallDescriptor描述，其中包括进程的pid和CallSignal信号。

	struct CallDescriptor {
	uint64_t pid;
	// TODO: add sourceModuleID and targetModuleID
	FunctionMonitor::CallSignal signal;
	};

整个函数调用的管理和组织使用CallDescriptorsMap来描述，这个结构是\<pc,CallDescriptor\>对：

	typedef std::tr1::unordered_multimap<uint64_t, CallDescriptor> CallDescriptorsMap;

2、函数返回的描述：

 

使用数据结构ReturnDescriptor描述，其中包括进程的pid和ReturnSignal信号。

	struct ReturnDescriptor {
	//S2EExecutionState *state;
	uint64_t pid;
	// TODO: add sourceModuleID and targetModuleID
	FunctionMonitor::ReturnSignal signal;
	};

整个函数返回的管理和组织使用ReturnDescriptorsMap来描述，这个结构是\<pc,ReturnDescriptor\>对：

	typedef std::tr1::unordered_multimap<uint64_t, ReturnDescriptor> ReturnDescriptorsMap;

####1.5.3.2 初始化

FunctionMonitor?
插件初始化时连接CorePlugin的两个信号：onTranslateBlockEnd和onTranslateJumpStart。

 

1、onTranslateBlockEnd（处理CallSignal信号）

 

首先判断当前的tb的类型是否是TB\_CALL或者TB\_CALL\_IND类型，tb的类型是通过tb的s2e\_tb\_type域来记录的，根据汇编指令来判断，如果是，则先调用函数FunctionMonitor::slotCall()，经过预处理DECLARE_PLUGINSTATE(FunctionMonitorState, state)后， 最 终 调 用
FunctionMonitorState::slotCall 函数进行处理:

	void FunctionMonitor::slotCall(S2EExecutionState *state, uint64_t pc)
	{
	    DECLARE_PLUGINSTATE(FunctionMonitorState, state);
	    return plgState->slotCall(state, pc);
	} 

	void FunctionMonitorState::slotCall(S2EExecutionState *state, uint64_t pc)
	{
	target_ulong pid = state->getPid();
	target_ulong eip = state->getPc();
	if (!m_newCallDescriptors.empty()) {
	m_callDescriptors.insert(m_newCallDescriptors.begin(),
	m_newCallDescriptors.end());
	m_newCallDescriptors.clear();
	}
	/* Issue signals attached to all calls (pc==-1 means catch-all) */
	//追踪进程的所有的函数调用
	if (!m_callDescriptors.empty()) {
	std::pair<CallDescriptorsMap::iterator, CallDescriptorsMap::iterator>
	range = m_callDescriptors.equal_range((uint64_t)-1);
	for(CallDescriptorsMap::iterator it = range.first; it != range.second; ++it) {
	CallDescriptor cd = (*it).second;
	if (m_plugin->m_monitor) {
	pid = m_plugin->m_monitor->getPid(state, pc);
	}
	if(it->second.pid == (uint64_t)-1 || it->second.pid == pid) {
	cd.signal.emit(state, this);
	}
	}
	if (!m_newCallDescriptors.empty()) {
	m_callDescriptors.insert(m_newCallDescriptors.begin(),
	m_newCallDescriptors.end());
	m_newCallDescriptors.clear();
	}
	}
	/* Issue signals attached to specific calls */
	//追踪特定的函数调用
	if (!m_callDescriptors.empty()) {
	std::pair<CallDescriptorsMap::iterator, CallDescriptorsMap::iterator>
	range;
	range = m_callDescriptors.equal_range(eip);
	for(CallDescriptorsMap::iterator it = range.first; it != range.second; ++it) {
	CallDescriptor cd = (*it).second;
	if (m_plugin->m_monitor) {
	pid = m_plugin->m_monitor->getPid(state, pc);
	}
	if(it->second.pid == (uint64_t)-1 || it->second.pid == pid) {
	cd.signal.emit(state, this);
	}
	}
	if (!m_newCallDescriptors.empty()) {
	m_callDescriptors.insert(m_newCallDescriptors.begin(),
	m_newCallDescriptors.end());
	m_newCallDescriptors.clear();
	}
	}
	}

这个函数中根据追踪特定的函数调用或者追踪所有的函数调用（根据pc值查找m\_callDescriptors映射,pc=-1时表示追踪所有的call），分别发送CallSignal信号。

 

2、onTranslateJumpStart（处理ReturnSignal信号）

 

首先判断当前tb的类型是否是JT\_RET或者JT\_LRET类型，如果是，则先调用FunctionMonitor::slotRet函数，进行预处理DECLARE_PLUGINSTATE(FunctionMonitorState, state)后最终调用FunctionMonitorState::slotRet函数进行处理，代码如下：

	void FunctionMonitor::slotRet(S2EExecutionState *state, uint64_t pc)
	{
	    DECLARE_PLUGINSTATE(FunctionMonitorState, state);

	    return plgState->slotRet(state, pc, true);
	}

	void FunctionMonitorState::slotRet(S2EExecutionState *state, uint64_t pc, bool emitSignal)
	{
	    target_ulong cr3 = state->readCpuState(CPU_OFFSET(cr[3]), 8*sizeof(target_ulong));

	    target_ulong esp;
	    bool ok = state->readCpuRegisterConcrete(CPU_OFFSET(regs[R_ESP]),
		                                     &esp, sizeof(target_ulong));
	    if(!ok) {
		target_ulong eip = state->readCpuState(CPU_OFFSET(eip),
		                                       8*sizeof(target_ulong));
		m_plugin->s2e()->getWarningsStream(state)
		    << "Function return with symbolic ESP!" << '\n'
		    << "  EIP=" << hexval(eip) << " CR3=" << hexval(cr3) << '\n';
		return;
	    }

	    if (m_returnDescriptors.empty()) {
		return;
	    }

	    //m_plugin->s2e()->getDebugStream() << "ESP AT RETURN 0x" << std::hex << esp <<
	    //        " plgstate=0x" << this << " EmitSignal=" << emitSignal <<  std::endl;

	    bool finished = true;
	    do {
		finished = true;
		std::pair<ReturnDescriptorsMap::iterator, ReturnDescriptorsMap::iterator>
		        range = m_returnDescriptors.equal_range(esp);
		for(ReturnDescriptorsMap::iterator it = range.first; it != range.second; ++it) {
		    if (m_plugin->m_monitor) {
		        cr3 = m_plugin->m_monitor->getPid(state, pc);
		    }

		    if(it->second.cr3 == cr3) {
		        if (emitSignal) {
		            it->second.signal.emit(state);
		        }
		        m_returnDescriptors.erase(it);
		        finished = false;
		        break;
		    }
		}
	    } while(!finished);
	}

这个函数根据栈顶地址sp，以及pid，判断当前进程是否正在执行ret指令，然后发送ReturnSignal信号。

 

####1.5.3.3 注册一个call信号

在我们自己的插件中，得到需要监视的函数地址后，需要注册一个call信号，用于连接FunctionMonitor发送出的call信号。

 

注册call信号时传入的参数是需要监视的函数地址和进程的pid，返回一个CallSignal。

	FunctionMonitor::CallSignal* FunctionMonitorState::getCallSignal(
	uint64_t pc, uint64_t pid)
	{
	std::pair<CallDescriptorsMap::iterator, CallDescriptorsMap::iterator>
	range = m_callDescriptors.equal_range(pc);
	}
	//在已存在的call信号中查找是否存在和申请注册的函数的pid一致的信号，如果存在则将已存在的
	//call信号的信号返回
	for(CallDescriptorsMap::iterator it = range.first; it != range.second; ++it) {
	if(it->second.pid == pid)
	return &it->second.signal;
	}
	//如果没有已存在的一致的信号，则按照传入的函数的参数创建一个call信号，并将其返回
	CallDescriptor descriptor = { pid, FunctionMonitor::CallSignal() };
	CallDescriptorsMap::iterator it =
	m_newCallDescriptors.insert(std::make_pair(pc, descriptor));
	return &it->second.signal;
